<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Marc Álvarez Blog</title>
        <description>Blog Personal</description>
        <language>en</language>
        <link>https://marcalv.com/blog/rss.xml</link>
        <atom:link href="https://marcalv.com/blog/rss.xml" rel="self" type="application/rss+xml"/>
        <image>
            <title>Marc Álvarez Blog</title>
            <url>https://marcalv.com/static/icons/icon_user.png</url>
            <link>https://marcalv.com/blog</link>
        </image>
        <!--item-->
<item>
<title>Servidor en casa - Parte 5: Acceso remoto mediante llaves de encriptado</title>
<link>https://marcalv.com/blog/008homeserver5</link>
<guid>008homeserver5</guid>
<author>Marc Álvarez</author>
<pubDate>Sun, 04 Oct 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 5: Acceso remoto mediante llaves de encriptado_--&gt;


&lt;!--pubdate:2020/10/04_--&gt;


&lt;!--moddate:2020/10/04_--&gt;


&lt;!--icon:raspberry_--&gt;




&lt;!--[![Enlace al video de esta parte.](/static/files/images/guiaraspi_thumbnail.png)](https://www.youtube.com/watch?v=qapw2nI-xyE)--&gt;


&lt;h2&gt;5.1 Acceso SSH mediante llaves de encriptado&lt;/h2&gt;

&lt;p&gt;A continuación configuraremos el acceso por SSH como usuario root a la Raspberry mediante de llaves de encriptado. A nivel de seguridad sería equivalente a usar una contraseña lo suficientemente larga.&lt;/p&gt;

&lt;p&gt;Sin embargo, obtendremos otros beneficios, como poder acceder por SSH desde los dispositivos autorizados sin escribir la contraseña al inicio de cada conexión. Esto será útil para poder automatizar el proceso de backup sin tener que lidiar con contraseñas. Otra ventaja es la posibilidad de administrar el acceso de cada uno de los dispositivos por separado.&lt;/p&gt;

&lt;h2&gt;5.2 Permitir el login root temporalmente&lt;/h2&gt;

&lt;p&gt;Entra por SSH a la Raspberry como el usuario pi, es decir, como siempre hasta ahora.&lt;/p&gt;

&lt;p&gt;Crea la contraseña del usuario root con &lt;code&gt;sudo passwd root&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Edita el archivo &lt;code&gt;ssdh_config&lt;/code&gt; con el comando &lt;code&gt;sudo nano /etc/ssh/sshd_config&lt;/code&gt; y descomentar la linea &lt;code&gt;PermitRootLogin yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Reinicia el servicio sshd con &lt;code&gt;sudo service sshd restart&lt;/code&gt; para poner en marcha la nueva configuración.&lt;/p&gt;

&lt;p&gt;Cierra la conexión y abre una nueva, pero ahora con el usuario root, con &lt;code&gt;ssh root@IP_RASPBERRY_LOCAL&lt;/code&gt;. Deberias poder conectarte correctamente una vez introduzcas la contraseña del usuario root que hemos configurado previamente.&lt;/p&gt;

&lt;h2&gt;5.3 Crear y enviar las llaves de encriptado&lt;/h2&gt;

&lt;p&gt;A continuación crearemos las llaves de encriptado en el dispositivo desde el cual nos conectamos por SSH a la Raspberry. Se creará una llave privada y una llave pública que será la que enviemos a la Raspberry y de esta forma nos autorice a conectarnos.&lt;/p&gt;

&lt;p&gt;Crea las llaves con &lt;code&gt;ssh-keygen -t rsa&lt;/code&gt;. Por defecto se guardaran dentro de la carpeta &lt;code&gt;.ssh&lt;/code&gt; situada en el directorio &lt;code&gt;home&lt;/code&gt; de tu sistema.&lt;/p&gt;

&lt;p&gt;Envíalas a la Raspberry con &lt;code&gt;ssh-copy-id root@IP_RASPBERRY_LOCAL&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Como puedes ver, para poder enviar la llave pública para acceder como usuario root, es indispensable habilitar el propio acceso root, que es lo que hemos hecho en el paso 5.3.&lt;/p&gt;

&lt;p&gt;Confirma que puedes acceder como root con el comando &lt;code&gt;ssh root@IP_RASPBERRY_LOCAL&lt;/code&gt; sin que ninguna contraseña sea solicitada. Sin embargo, aún sería posible acceder como root desde otro dispositivo sin contraseña.&lt;/p&gt;

&lt;h2&gt;5.4 Bloquear el acceso con contraseña&lt;/h2&gt;

&lt;p&gt;Dada la política actual de acceso que hemos configurado en el apartado 5.2 con la línea &lt;code&gt;PermitRootLogin yes&lt;/code&gt;, otros dispositivos siguen pudiendo acceder mediante contraseña. Para evitar esto cambiaremos la directriz de la configuración a &lt;code&gt;PermitRootLogin without-password&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Al igual que en el punto 5.2, modifica el archivo &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; y sustituye la línea &lt;code&gt;PermitRootLogin yes&lt;/code&gt; por &lt;code&gt;PermitRootLogin without-password&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Reiniciar el servicio sshd con &lt;code&gt;sudo service sshd restart&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;¡ATENCIÓN! Mi consejo es que no cerréis la ventana actual&lt;/strong&gt;. Comprobad en otra terminal que podéis acceder con &lt;code&gt;ssh root@IP_RASPBERRY_LOCAL&lt;/code&gt; correctamente y sin contraseña.&lt;/p&gt;

&lt;p&gt;Si la directriz se configura como &lt;code&gt;PermitRootLogin without-password&lt;/code&gt; y las llaves no se han copiado correctamente, nos quedaríamos sin acceso remoto. Este problema sería equivalente a perder la contraseña de acceso. Lee el siguiente punto para entender donde se guardan las llaves en la Raspberry y asegurarte de que se ha copiado.&lt;/p&gt;

&lt;h2&gt;5.5 Administrar acceso&lt;/h2&gt;

&lt;p&gt;Con este método se pueden configurar diferentes dispositivos para accedan remótamente sin contraseña. Para poder eliminar este acceso, en la Raspberry edita el siguiente fichero con: &lt;code&gt;sudo nano /root/.ssh/authorized_keys&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Cada línea de este archivo es una llave de cada dispositivo. Al final de cada línea podrás ver con más fácilidad de que dispositivo se trata. Para eliminar el acceso, simplemente borra la línea asociada al dispositivo.&lt;/p&gt;
</description>
</item>
<item>
<title>Servidor en casa - Parte 4: Instalando Qbittorrent, Jackett y Wireguard</title>
<link>https://marcalv.com/blog/007homeserver4</link>
<guid>007homeserver4</guid>
<author>Marc Álvarez</author>
<pubDate>Sat, 26 Sep 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 4: Instalando Qbittorrent, Jackett y Wireguard_--&gt;


&lt;!--pubdate:2020/09/26_--&gt;


&lt;!--moddate:2020/09/26_--&gt;


&lt;!--icon:raspberry_--&gt;


&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=qapw2nI-xyE&quot;&gt;&lt;img src=&quot;/static/files/images/guiaraspi_thumbnail.png&quot; alt=&quot;Enlace al video de esta parte.&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;4.1 Contenedor Qbittorent&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-qbitorrent&quot;&gt;github.com/linuxserver/docker-qbitorrent&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Añade a &lt;code&gt;docker-compose.yml&lt;/code&gt; las lineas del servicio que puedes encontrar en la parte 2 de la guía, o en la documentación del contenedor (link anterior). Levanta el contenedor con:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose up -d qbittorrent &amp;amp;&amp;amp; sudo docker logs -f qbittorrent
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Crear reverse-proxy&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cp /home/pi/compose/data/swag/config/nginx/proxy-confs/qbittorrent.subfolder.conf.sample /home/pi/compose/data/swag/config/nginx/proxy-confs/qbittorrent.subfolder.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reinicia SWAG con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose restart swag &amp;amp;&amp;amp; sudo docker logs -f swag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accede al servicio con &lt;code&gt;TU_DOMINIO.duckdns.org/jackett&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;4.2 Levantar el contenedor Jackett&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-jackett&quot;&gt;github.com/linuxserver/docker-jackett&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Añade a &lt;code&gt;docker-compose.yml&lt;/code&gt; las lineas del servicio que puedes encontrar en la parte 2 de la guía, o en la documentación del contenedor (link anterior).
Levanta el contenedor con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose up -d jackett &amp;amp;&amp;amp; sudo docker logs -f jackett
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Crear reverse-proxy&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cp /home/pi/compose/data/swag/config/nginx/proxy-confs/jackett.subfolder.conf.sample /home/pi/compose/data/swag/config/nginx/proxy-confs/jackett.subfolder.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accede a &lt;code&gt;http://IP_RASPBERRY_LOCAL:9117&lt;/code&gt;, en path override escribe &lt;code&gt;/jackett&lt;/code&gt; y configura una contraseña de administrador.&lt;/p&gt;

&lt;p&gt;Reinicia SWAG y jackett con:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose restart swag &amp;amp;&amp;amp; sudo docker logs -f swag
sudo docker-compose restart jackett &amp;amp;&amp;amp; sudo docker logs -f jackett
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accede al servicio con &lt;code&gt;TU_DOMINIO.duckdns.org/jackett&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;4.3 Web estática&lt;/h2&gt;

&lt;p&gt;Puedes colocar los archivos de tu web estática en &lt;code&gt;/home/pi/compose/data/swag/config/www/&lt;/code&gt; y acceder mediante &lt;code&gt;tudominio.duckdns.org&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;4.4 Wireguard&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-wireguard&quot;&gt;github.com/linuxserver/docker-wireguard&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Añade a &lt;code&gt;docker-compose.yml&lt;/code&gt; las lineas del servicio que puedes encontrar en la parte 2 de la guía, o en la documentación del contenedor (link anterior).&lt;/p&gt;

&lt;p&gt;Levanta el contenedor con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose up -d wireguard &amp;amp;&amp;amp; sudo docker logs -f wireguard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redirige el puerto &lt;code&gt;51820&lt;/code&gt; en el router a la IP de tu Raspberry. No requiere reverse-proxy. Los credenciales para conectarse a la VPN se van a la carpeta de configuración (volumen externo del contenedor).&lt;/p&gt;

&lt;p&gt;Para conectarte a la VPN, necesitaras los archivos &lt;code&gt;peerX.conf&lt;/code&gt; o los códigos QR que en este caso se encontrarán en &lt;code&gt;/home/pi/compose/data/wireguard/config&lt;/code&gt; si usas la configuración de la parte 2 de la guía.&lt;/p&gt;

&lt;p&gt;Toda la información está en el repositorio del proyecto.&lt;/p&gt;
</description>
</item>
<item>
<title>Servidor en casa - Parte 3: Instalando Nextcloud</title>
<link>https://marcalv.com/blog/006homeserver3</link>
<guid>006homeserver3</guid>
<author>Marc Álvarez</author>
<pubDate>Sat, 26 Sep 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 3: Instalando Nextcloud_--&gt;


&lt;!--pubdate:2020/09/26_--&gt;


&lt;!--moddate:2020/09/26_--&gt;


&lt;!--icon:raspberry_--&gt;


&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tsbltEpkSiI&quot;&gt;&lt;img src=&quot;/static/files/images/guiaraspi_thumbnail.png&quot; alt=&quot;Enlace al video de esta parte.&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.1 Contenedor Nextcloud&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-nextcloud&quot;&gt;github.com/linuxserver/docker-nextcloud&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Si antes no has pegado todos los servicios en el archivo &lt;code&gt;docker-compose.yml&lt;/code&gt;, asegurate de añadir las lineas del servicio &lt;code&gt;nextcloud&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Levanta el contenedor con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose up -d nextcloud &amp;amp;&amp;amp; sudo docker logs -f nextcloud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Comprueba que la web carga accediendo a &lt;code&gt;https://IP_RASPBERRY_LOCAL:2443&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Crear reverse-proxy&lt;/h3&gt;

&lt;p&gt;Al igual que con Pi-hole, habilitamos la configuración para crear el reverse-proxy para Nextcloud, al cual accederemos desde el subdiretorio &lt;code&gt;/nextcloud&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /home/pi/compose/data/swag/config/nginx/proxy-confs/nextcloud.subfolder.conf.sample /home/pi/compose/data/swag/config/nginx/proxy-confs/nextcloud.subfolder.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edita el archivo &lt;code&gt;nextcloud.subfolder.conf&lt;/code&gt; y modifica el 2048 por 1024:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nano /home/pi/compose/data/swag/config/nginx/proxy-confs/nextcloud.subfolder.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Edita el archivo &lt;code&gt;config.php&lt;/code&gt; con el comando&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nano /home/pi/compose/data/config/www/nextcloud/config/config.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;y añade antes del &lt;code&gt;);&lt;/code&gt; lo siguiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&apos;trusted_proxies&apos; =&amp;gt; [&apos;swag&apos;],
  &apos;overwritewebroot&apos; =&amp;gt; &apos;/nextcloud&apos;,
  &apos;overwrite.cli.url&apos; =&amp;gt; &apos;https://TU_DOMINIO.duckdns.org/nextcloud&apos;,
  &apos;trusted_domains&apos; =&amp;gt;
  array (
    0 =&amp;gt; &apos;192.168.1.11&apos;,   #Tu IP LOCAL
    1 =&amp;gt; &apos;TU_DOMINIO.duckdns.org&apos;,
  ),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modifica tu dominio (dos veces) y tu IP local.&lt;/p&gt;

&lt;p&gt;Reiniciar SWAG y Nextcloud con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose restart swag &amp;amp;&amp;amp; sudo docker logs -f swag
sudo docker-compose restart nextcloud &amp;amp;&amp;amp; sudo docker logs -f nextcloud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Accede a &lt;a href=&quot;https://TU_DOMINIO.duckdns.org/nextcloud/&quot;&gt;https://TU_DOMINIO.duckdns.org/nextcloud/&lt;/a&gt; para comprobar que funciona, tanto dentro como fuera de la red local.&lt;/p&gt;

&lt;h3&gt;Bonus: Desactivar chunks para subir archivos grandes a máxima velocidad&lt;/h3&gt;

&lt;p&gt;Con los siguientes comandas iniciarás la consola dentro del contenedor y configuraras php para que deshabilite el corte por chunks al subir y bajar archivos de nextcloud.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker exec -it nextcloud /bin/bash
cd /config/www/nextcloud
sudo -u abc php occ config:app:set files max_chunk_size --value 0
&lt;/code&gt;&lt;/pre&gt;
</description>
</item>
<item>
<title>Servidor en casa - Parte 2: Conexión a la red</title>
<link>https://marcalv.com/blog/005homeserver2</link>
<guid>005homeserver2</guid>
<author>Marc Álvarez</author>
<pubDate>Sat, 26 Sep 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 2: Conexión a la red_--&gt;


&lt;!--pubdate:2020/09/26_--&gt;


&lt;!--moddate:2020/09/26_--&gt;


&lt;!--icon:raspberry_--&gt;


&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=c4J7Ya6reUY&quot;&gt;&lt;img src=&quot;/static/files/images/guiaraspi_thumbnail.png&quot; alt=&quot;Enlace al video de esta parte.&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2.1 Abrir puertos&lt;/h2&gt;

&lt;p&gt;Configura en &lt;a href=&quot;http://192.168.1.1&quot;&gt;tu router&lt;/a&gt; las siguientes redirecciónes de puertos públicos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Puerto público 443 a la IP de tu raspberry, puerto 443.&lt;/li&gt;
&lt;li&gt;Puerto público 80 a la IP de tu raspberry, puerto 80.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2.2 Instalar dependecias&lt;/h2&gt;

&lt;p&gt;Volvemos a la raspberry. Ahora instalaremos docker-compose y lo activaremos con los siguientes comandos:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt install docker-compose
sudo systemctl enable docker
sudo reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2.3 Crear docker-compose.yml&lt;/h2&gt;

&lt;p&gt;Creamos el archivo docker-compose.yml.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir compose
cd compose
nano docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Contenido del archivo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
version: &apos;2.1&apos;
services:
  duckdns:
    image: linuxserver/duckdns
    container_name: duckdns
    environment:
      - PUID=1000 #optional
      - PGID=1000 #optional
      - TZ=Europe/Madrid
      - SUBDOMAINS=TU_SUBDOMINIO,
      - TOKEN=TU_TOKEN
      - LOG_FILE=false #optional
    volumes:
      - /home/pi/compose/data/duckdns/config:/config #optional
    restart: unless-stopped

  swag:
    image: linuxserver/swag
    container_name: swag
    cap_add:
      - NET_ADMIN
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
      - URL=TU_SUBDOMINIO.duckdns.org
      - SUBDOMAINS=www,
      - VALIDATION=duckdns
      - DNSPLUGIN=cloudflare #optional
      - PROPAGATION= #optional
      - DUCKDNSTOKEN=TU_TOKEN
      - EMAIL= #optional
      - ONLY_SUBDOMAINS=false #optional
      - EXTRA_DOMAINS= #optional
      - STAGING=false #optional
    volumes:
      - /home/pi/compose/data/swag/config:/config
    ports:
      - 443:443
      - 80:80 #optional
    restart: unless-stopped

  pihole:
    container_name: pihole
    image: pihole/pihole:latest
    ports:
      - 53:53/tcp
      - 53:53/udp
      - 67:67/udp
      - 1080:80/tcp
      - 1443:443/tcp
    environment:
      TZ: Europe/Madrid
    volumes:
       - /home/pi/compose/data/pihole/etc-pihole/:/etc/pihole/
       - /home/pi/compose/data/pihole/etc-dnsmasq.d/:/etc/dnsmasq.d/
    dns:
      - 127.0.0.1
      - 1.1.1.1
    cap_add:
      - NET_ADMIN
    restart: unless-stopped

  nextcloud:
    image: linuxserver/nextcloud
    container_name: nextcloud
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
    volumes:
      - /home/pi/compose/data/nextcloud/config:/config
      - /home/pi/compose/data/nextcloud/data:/data
    ports:
      - 2443:443
    restart: unless-stopped

  qbittorrent:
    image: linuxserver/qbittorrent
    container_name: qbittorrent
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
      - UMASK_SET=022
      - WEBUI_PORT=8080
    volumes:
      - /home/pi/compose/data/qbittorrent/config:/config
      - /home/pi/compose/data/qbittorrent/downloads:/downloads
    ports:
      - 6881:6881
      - 6881:6881/udp
      - 3080:8080
    restart: unless-stopped

  jackett:
    image: linuxserver/jackett
    container_name: jackett
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
      - AUTO_UPDATE=true #optional
      - RUN_OPTS=&amp;lt;run options here&amp;gt; #optional
    volumes:
      - /home/pi/compose/data/jackett/config:/config
      - /home/pi/compose/data/jackett/downloads:/downloads
    ports:
      - 9117:9117
    restart: unless-stopped

  wireguard:
    image: linuxserver/wireguard
    container_name: wireguard
    cap_add:
      - NET_ADMIN
      - SYS_MODULE
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Madrid
      - SERVERURL=TU_SUBDOMINIO.duckdns.org
      - SERVERPORT=51820 #optional
      - PEERS=2 #optional
      - PEERDNS=auto
      - INTERNAL_SUBNET=10.13.13.0 #optional
    volumes:
      - /home/pi/compose/data/wireguard/config:/config
      - /lib/modules:/lib/modules   # no modificar
    ports:
      - 51820:51820/udp     # Redireccionar puerto en router
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    restart: unless-stopped
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Importante:&lt;/strong&gt; Las tabulaciones son importantes. Confirma que delante de cada nombre de servicio (swag, pihole, nextcloud) hay dos espacios.&lt;/p&gt;

&lt;h2&gt;2.4 Contenedor duckdns&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-duckdns&quot;&gt;github.com/linuxserver/docker-duckdns&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Crear cuenta en duckdns.org&lt;/h3&gt;

&lt;p&gt;Crear cuenta en &lt;a href=&quot;duckdns.org&quot;&gt;duckdns.org&lt;/a&gt;, crear subdominio con IP aleatoria, para posteriormente comprobar que se actualiza con la IP pública de nuestro router real.&lt;/p&gt;

&lt;h3&gt;Personalizar duckdns en docker-compose.yml&lt;/h3&gt;

&lt;p&gt;Dentro del servicio duckdns, reemplaza los campos &lt;code&gt;SUBDOMAINS&lt;/code&gt; y &lt;code&gt;TOKEN&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Levantar duckdns&lt;/h3&gt;

&lt;p&gt;Levanta el contenedor con &lt;code&gt;sudo docker-compose up -d duckdns&lt;/code&gt;, estando en dentro de la carpeta &lt;code&gt;compose&lt;/code&gt; que contiene el archivo &lt;code&gt;docker-compose.yml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para confirmar que el contenedor se ha levantado correctamente, usa el comando &lt;code&gt;sudo docker logs -f duckdns&lt;/code&gt; para visualizar los registros. Usa &lt;code&gt;Ctrl+C&lt;/code&gt; para cerrar el visualizador.&lt;/p&gt;

&lt;p&gt;Confirma que en el panel de control de duckdns.org la IP de tu subdominio se ha actualizado con tu IP real.&lt;/p&gt;

&lt;h2&gt;2.5 Contenedor SWAG&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: &lt;a href=&quot;https://github.com/linuxserver/docker-swag&quot;&gt;github.com/linuxserver/docker-swag&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Personalizar swag en docker-compose.yml&lt;/h3&gt;

&lt;p&gt;Personaliza en el bloque del servicio &lt;code&gt;swag&lt;/code&gt; el campo &lt;code&gt;URL&lt;/code&gt; y el &lt;code&gt;DUCKDNSTOKEN&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Levantar SWAG&lt;/h3&gt;

&lt;p&gt;Levanta el contenedor con &lt;code&gt;sudo docker-compose up -d swag &amp;amp;&amp;amp; sudo docker logs -f swag&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Si has configurado bien el router y el docker-compose.yml, deberá aparecerte una linea con &amp;ldquo;Congratulations&amp;rdquo;. Si obtienes errores, tendras que revisar la configuración. Estos comandos de docker-compose te pueden ser útiles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker-compose up -d swag # Crear y arrancar contenedor
docker-compose stop swag # Parar contenedor 
docker-compose start swag # Arrancar contenedor
docker-compose down swag #Parar y eliminar contenedor
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Comprobación&lt;/h3&gt;

&lt;p&gt;Entra en  &lt;code&gt;https://IP_RASPBERRY_LOCAL&lt;/code&gt;, te aparecerá una advertencia, acepta los riesgos. Veras una web simple si todo está  correcto.&lt;/p&gt;

&lt;p&gt;En función de si tu router soporta NAT loopback, los siguientes resultados pueden variar.&lt;/p&gt;

&lt;p&gt;Si entras en https://marcloud.duckdns.org sin problemas, tu router soporta NAT loopback. Si no te funciona, entra desde un móvil con datos, no WiFi. Si ahora funciona todo esta bien, pero tu router no soporta NAT loopback.&lt;/p&gt;

&lt;p&gt;Para solucionar este problema, se instala Pi-hole que actúa como intermediario entre el router y tu dispositivo, realizando la función de NAT loopback, pudiendo acceder con el dominio de duckdns desde dentro de la red local.&lt;/p&gt;

&lt;h2&gt;2.6 Contenedor Pi-hole&lt;/h2&gt;

&lt;p&gt;Más información del contenedor: https://github.com/pi-hole/docker-pi-hole&lt;/p&gt;

&lt;h3&gt;Levantar Pi-hole&lt;/h3&gt;

&lt;p&gt;Levanta Pi-hole:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose up -d pihole &amp;amp;&amp;amp; sudo docker logs -f pihole
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configura la contraseña de acceso: &lt;code&gt;sudo docker exec -it pihole pihole -a -p&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Accede a &lt;code&gt;http://IP_RASPBERRY_LOCAL:1080/admin/&lt;/code&gt; para comprobar que funciona.&lt;/p&gt;

&lt;p&gt;Ahora añadiremos la regla que nos permita acceder localmente a nuestro dominio. Para ello entramos a Pihole desde &lt;code&gt;http://IP_RASPBERRY_LOCAL:1080/admin/&lt;/code&gt; por última vez, y en &lt;code&gt;DNS Records&lt;/code&gt; añadimos una regla que redirija el dominio &lt;code&gt;TU_DOMINIO.duckdns.org&lt;/code&gt; a la IP de tu Raspberry, en mi caso &lt;code&gt;192.168.1.11&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Para evitar problemas, edita la siguiente configuración. Dirígete a Settings, DNS, desmcarca todas las casillas de la parte izquierda y añade, a la derecha, un custom DNS server marcando su casilla y escribiendo en la caja de texto &lt;code&gt;192.168.1.1&lt;/code&gt;. Usa el boton al final de la página para guardar. Con esto hacemos que la Raspberry use como servidor DNS el router.&lt;/p&gt;

&lt;h3&gt;Configurar el DNS en tus dispositivos&lt;/h3&gt;

&lt;p&gt;En el video muestro como configurar el DNS de forma manual en un dispositivo Android (26:40) y en el sistema operativo Linux con KDE (29:05). Para otros sistemas operativos te facilito otras guias que pueden servirte de ayuda:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.windowscentral.com/how-change-your-pcs-dns-settings-windows-10&quot;&gt;Para Windows&lt;/a&gt; Recomiendo la segunda opción (vía Settings y no el panel de control), para que la configuración quede modificada en una conexión en específico y no en todas. En una red diferente a la de tu casa no te interesa tener el DNS apuntando a la IP de tu raspberry, porque básicmente no estará ahí.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.support.com/how-to/how-to-change-dns-settings-on-a-mac-10189&quot;&gt;Para MAC&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Crear reverse-proxy&lt;/h3&gt;

&lt;p&gt;El objetivo es poder acceder al panel de control desde fuera de la red local (acceso público) a traves del subdirectorio /pihole, es decir, en &lt;code&gt;TU_SUBDOMINIO.duckdns.org/pihole/admin&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Habilitaremos el archivo que contiene esta configuración con el siguiente comando:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cp /home/pi/compose/data/swag/config/nginx/proxy-confs/pihole.subfolder.conf.sample /home/pi/compose/data/swag/config/nginx/proxy-confs/pihole.subfolder.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con este comando copiamos el archivo &lt;code&gt;pihole.subfolder.conf.sample&lt;/code&gt; sin la extensión &lt;code&gt;.sample&lt;/code&gt; para que nginx lo lea (contenedor SWAG). Al inicio de este archivo se encuentran las instrucciones en caso de que sea necesario modificar alguna configuración más. En este caso no es necesario.&lt;/p&gt;

&lt;p&gt;Reiniciamos SWAG con&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo docker-compose restart swag &amp;amp;&amp;amp; sudo docker logs -f  swag
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Desde la red local con un dispositico con el DNS condifigurado correctamente comprueba que puedes entrar a https://marcloud.duckdns.org/pihole/admin/. Desde fuera de la red local, cualquier dispositivo deberia poder acceder también.&lt;/p&gt;

&lt;h2&gt;2.7 Notas adicionales&lt;/h2&gt;

&lt;p&gt;Con respecto al problema del NAT loopback, existe otra solución que consiste en que Pihole actue como servidor DHCP de la red local pero la estabilidad de toda la red recae sobre nuestro proyecto. Ésta seria una opción a considerar una vez se comprueba que el sistema es estable. Con ello nos ahorrariamos tener que configurar en cada dispositivo que el servidor DNS es la Raspberry.&lt;/p&gt;

&lt;p&gt;Para ello bastaria desactivar el serviodor DHCP en el router y activarlo en Pi-hole. Habría que configurar, eso sí, las reglas de IP locales estáticas otra vez, esta vez, en Pi-hole ya que es ahora la encargada de establecerlas.&lt;/p&gt;
</description>
</item>
<item>
<title>Servidor en casa - Parte 1: Puesta en marcha de la Raspberry Pi</title>
<link>https://marcalv.com/blog/004homeserver1</link>
<guid>004homeserver1</guid>
<author>Marc Álvarez</author>
<pubDate>Sat, 26 Sep 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 1: Puesta en marcha de la Raspberry Pi_--&gt;


&lt;!--pubdate:2020/09/26_--&gt;


&lt;!--moddate:2020/09/26_--&gt;


&lt;!--icon:raspberry_--&gt;


&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=OAY0VTnHiMw&quot;&gt;&lt;img src=&quot;/static/files/images/guiaraspi_thumbnail.png&quot; alt=&quot;Enlace al video de esta parte.&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;1.1 Instalar Raspberry Pi OS Lite (Healess)&lt;/h2&gt;

&lt;p&gt;Descargar Raspberry Pi Imager de &lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot;&gt;aquí&lt;/a&gt; para copiar el SO a la tarjeta SD.&lt;/p&gt;

&lt;p&gt;Abrir Pi Imager, seleccionar Raspberry PI OS Lite (32-BIT), seleccionar la tarjeta SD y Write. Cerrar el programa una vez finalizado.&lt;/p&gt;

&lt;h2&gt;1.2 Preparación de la conexión por SSH&lt;/h2&gt;

&lt;p&gt;No expulses la tarjeta SD del PC aún.
Accederemos a la Raspberry por SSH una vez haya arrancado, no necesitaremos conectarla a ninguna pantalla ni teclado. Por motivos de seguridad el acceso por ssh esta deshabilitado por defecto. En el siguiente paso lo habilitamos.&lt;/p&gt;

&lt;h3&gt;Habilitar acceso por SSH&lt;/h3&gt;

&lt;p&gt;Para habilitarlo se crea el archivo en blanco de nombre &lt;code&gt;ssh&lt;/code&gt; (sin extensión) en la partición &lt;code&gt;/boot&lt;/code&gt; de la SD.&lt;/p&gt;

&lt;h3&gt;(Opcional) Configurar conexión WiFi&lt;/h3&gt;

&lt;p&gt;Si vas a conectar la Raspberry por Ethernet este paso no es necesario. Si solo dispones de conexión WiFi, puedes configurarla creando un archivo archivo &lt;code&gt;wpa_supplicant.conf&lt;/code&gt; en &lt;code&gt;/boot&lt;/code&gt;. El contenido debe ser el siguiente:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;country=ES
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
    ssid=&quot;NETWORK-NAME&quot;
    psk=&quot;NETWORK-PASSWORD&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La lista con los códigos para cada país se puede consultar &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2&quot;&gt;aquí&lt;/a&gt;. Reemplaza &lt;code&gt;NETWORK-NAME&lt;/code&gt; y &lt;code&gt;NETWORK-PASSWORD&lt;/code&gt; con los credenciales de tu WiFi.&lt;/p&gt;

&lt;h2&gt;1.3 Primer arranque&lt;/h2&gt;

&lt;p&gt;Ahora  sí, podemos desmontar la SD del PC. A continuación la introducimos en la Raspberry, conectamos el cable de Ethernet si tenemos, y por último la alimentación. Arrancará automáticamente.&lt;/p&gt;

&lt;h3&gt;IP estática&lt;/h3&gt;

&lt;p&gt;Mientras la Raspberry arranca, accede a &lt;a href=&quot;http://192.168.1.1&quot;&gt;tu Router&lt;/a&gt;, localiza la IP que se le ha asignado y hazla estática.&lt;/p&gt;

&lt;h3&gt;Configuración básica&lt;/h3&gt;

&lt;p&gt;Tanto si estas en Windows, como Mac o Linux todos los comandos utilizados son los mismos. Para conectarnos por SSH, conociendo ya la IP de la Raspberry, abrimos una terminal o consola y ejecutamos el comando &lt;code&gt;ssh pi@IP_RASPBERRY_LOCAL&lt;/code&gt;. En mi caso el comando queda como &lt;code&gt;ssh pi@192.168.1.11&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Si todo va bien, en la primera conexión nos aparecerá una pregunta a la que responderemos &lt;code&gt;yes&lt;/code&gt;. A continuación se nos pedirá la contraseña, que por defecto es &lt;code&gt;raspberry&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A continuación realizaremos unos ajustes básicos ejecutando el comando &lt;code&gt;sudo raspi-config&lt;/code&gt;. En este menú seleccionamos cambiar la contraseña del usuario e introducimos una nueva. Después, en &amp;lsquo;Advanced&amp;rsquo;, entramos en la opción &amp;lsquo;Expand filesystem&amp;rsquo;. Una vez finalizado, nos pedirá reiniciar, a lo que responderemos que si.&lt;/p&gt;

&lt;p&gt;Automáticamente se cerrará la conexión ssh. Tras un minuto, puedes volver a ejecutar el comando &lt;code&gt;ssh pi@IP_RASPBERRY_LOCAL&lt;/code&gt; para volver a conectarte.&lt;/p&gt;

&lt;p&gt;Por último, ejecutaremos el comando &lt;code&gt;actualizar con sudo apt update &amp;amp;&amp;amp; sudo apt upgrade -y&lt;/code&gt; que actualizará los paquetes de la Raspberry a la última versión. Después, &lt;code&gt;sudo reboot&lt;/code&gt; para reiniciar.&lt;/p&gt;

&lt;h2&gt;1.4 (Opcional, recomendado) Automontar disco duro externo.&lt;/h2&gt;

&lt;h3&gt;Formateo&lt;/h3&gt;

&lt;p&gt;Deberemos formatear el USB o disco duro que conectaremos a la Raspberry en &lt;code&gt;ext4&lt;/code&gt;. En él almacenaremos todos los datos personales. En Linux puedes hacerlo con el administrador de particiones que tenga tu distribución. Si sólo dispones de Windows puedes encontrar por internet diferentes herramientas que formateen en &lt;code&gt;ext4&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;Automontar el disco duro externo&lt;/h3&gt;

&lt;p&gt;Arrancada la Raspberry, &lt;strong&gt;sin&lt;/strong&gt; insertar el USB ejecuta por ssh el comando &lt;code&gt;sudo blkid&lt;/code&gt;.
A continuación conecta el USB y vuelve a ejecutar el comando &lt;code&gt;sudo blkid&lt;/code&gt;. En esta segunda ocasión habrá aparecido una nueva linea que se corresponde con el USB que has insertado. Anota el UUID.&lt;/p&gt;

&lt;p&gt;Para automontar el USB editamos el archivo &lt;code&gt;fstab&lt;/code&gt; con el comando &lt;code&gt;sudo nano /etc/fstab&lt;/code&gt; y añadimos la siguiente linea al final del mismo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UUID=EL_UUID_DE_TU_USB /mnt/usb ext4  rw,users,exec 0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reemplaza &lt;code&gt;EL_UUID_DE_TU_USB&lt;/code&gt;  por tu UUID, y usa &lt;code&gt;Ctrl+x&lt;/code&gt; para salir del editor.&lt;/p&gt;

&lt;p&gt;Ejecuta el comando &lt;code&gt;sudo mkdir /mnt/usb&lt;/code&gt;. Con esto conseguimos que a cada arranque el USB se monte en la ruta &lt;code&gt;/mnt/usb&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Reiniciamos con &lt;code&gt;sudo reboot&lt;/code&gt; y comprobamos que el USB se ha montado correctamente. Para ello puedes usar el comando &lt;code&gt;cat /proc/mounts&lt;/code&gt;. En una de las lineas que devuelve debe aparecer el USB montado en la ruta anterior.&lt;/p&gt;
</description>
</item>
<item>
<title>Servidor en casa - Parte 0: Introducción</title>
<link>https://marcalv.com/blog/003homeserver0</link>
<guid>003homeserver0</guid>
<author>Marc Álvarez</author>
<pubDate>Sat, 26 Sep 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Servidor en casa - Parte 0: Introducción_--&gt;


&lt;!--pubdate:2020/09/26_--&gt;


&lt;!--moddate:2020/09/26_--&gt;


&lt;!--icon:raspberry_--&gt;


&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=LUEv2ELG5yg&quot;&gt;&lt;img src=&quot;/static/files/images/guiaraspi_thumbnail.png&quot; alt=&quot;Enlace al video de esta parte.&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;Enlaces de interés&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://opensource.com/resources/what-docker&quot;&gt;Que es un Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;linuxserver&quot;&gt;Linuxserver.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fleet.linuxserver.io/&quot;&gt;Lista de contenedores en Linuxserver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/linuxserver/&quot;&gt;Linuxserver en Github&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://nextcloud.com/&quot;&gt;Nextcloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pi-hole.net/&quot;&gt;Pi-hole&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Jackett/Jackett&quot;&gt;Jackett&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>
<item>
<title>Adding an RSS feed to this blog</title>
<link>https://marcalv.com/blog/002blogrss</link>
<guid>002blogrss</guid>
<author>Marc Álvarez</author>
<pubDate>Wed, 05 Aug 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Adding an RSS feed to this blog_--&gt;


&lt;!--pubdate:2020/08/05_--&gt;


&lt;!--moddate:2020/08/05_--&gt;


&lt;!--icon:rss_--&gt;


&lt;h2&gt;What is RSS and why I use it&lt;/h2&gt;

&lt;p&gt;Since I decided to leave Instagram and other social media sites, I started searching for other ways to keep me informed. This is how I have discovered &lt;a href=&quot;https://en.wikipedia.org/wiki/RSS&quot;&gt;RSS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An RSS is basically a web feed that allows users to get updates from a specific website (in case it offers one). For example, one can find this RSS feeds in newspaper websites like &lt;a href=&quot;https://servicios.elpais.com/rss/&quot;&gt;El País&lt;/a&gt;. This RSS feed are added to an RSS aggregator, which basically aggregates multiple feeds in one location for easy viewing.&lt;/p&gt;

&lt;p&gt;In my home server, as I explain &lt;a href=&quot;https://marcalv.com/blog/000thiswebsite&quot;&gt;here&lt;/a&gt;, I have a FreshRSS instance running. It&amp;rsquo;s a self-hostable feed aggregator that syncs with my phone and laptop. Among others, I have the following feeds added that may result you interesting or inspiring:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux distributions news: As a linux user, I like to keep updated with the latest news of the distribution that I use (currently &lt;a href=&quot;https://endeavouros.com/feed/&quot;&gt;EndeavourOS&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;Technology related blogs:  &lt;a href=&quot;https://www.muylinux.com/feed/&quot;&gt;MuyLinux&lt;/a&gt;, &lt;a href=&quot;https://codingfactsblog.wordpress.com/feed/&quot;&gt;CodingFacts&lt;/a&gt;&amp;hellip;&lt;/li&gt;
&lt;li&gt;Local news: &lt;a href=&quot;https://api.ccma.cat/noticies?_format=rss&amp;amp;origen=frontal&amp;amp;frontal=n324-portada-noticia&amp;amp;version=2.0&quot;&gt;324.cat&lt;/a&gt;, &lt;a href=&quot;https://www.abc.es/rss/feeds/abcPortada.xml&quot;&gt;ABC&lt;/a&gt;, &lt;a href=&quot;https://www.ara.cat/rss/latest/&quot;&gt;Ara.cat&lt;/a&gt;, &lt;a href=&quot;https://www.thespainreport.es/es/rss&quot;&gt;The Spain Report&lt;/a&gt;&amp;hellip;&lt;/li&gt;
&lt;li&gt;YouTube: I&amp;rsquo;m subscribed to divulgation channels like &lt;a href=&quot;https://invidio.us/feed/channel/UC6nSFpj9HTCZ5t-N3Rm3-HA&quot;&gt;Vsauce&lt;/a&gt;, &lt;a href=&quot;https://invidio.us/feed/channel/UCJ0-OtVpF0wOKEqT2Z1HEtA&quot;&gt;ElectroBOOM&lt;/a&gt; or &lt;a href=&quot;https://invidio.us/feed/channel/UCnkp4xDOwqqJD7sSM3xdUiQ&quot;&gt;Adam Neely&lt;/a&gt; through &lt;a href=&quot;https://invidio.us&quot;&gt;Invidio.us&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Twitter: I&amp;rsquo;m a huge fan of Extremoduro and I like to keep updated with their latest news. Sadly, their website does not offer an rss feed so I&amp;rsquo;m using &lt;a href=&quot;https://nitter.net&quot;&gt;Nitter&lt;/a&gt; to get an &lt;a href=&quot;https://nitter.net/Oficina_Extremo/rss&quot;&gt;rss feed&lt;/a&gt; from their twitter timeline.&lt;/li&gt;
&lt;li&gt;Instagram: my local gym posts all news on Instagram, so I&amp;rsquo;m using &lt;a href=&quot;https://github.com/RSS-Bridge/rss-bridge&quot;&gt;BridgeRSS&lt;/a&gt;. This service generates an RSS feed for a given user. I have my own instance hosted on Heroku. It is as easy as creating an Heroku account and using a &lt;a href=&quot;https://github.com/RSS-Bridge/rss-bridge#deploy&quot;&gt;single button click&lt;/a&gt; to deploy your own instance.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Overall, I believe this is a much efficient and less distracting way of keeping up to date than rather visiting all this services one by one. This is what I want and this is what I get. No more, no less.&lt;/p&gt;

&lt;h2&gt;Adding RSS to this blog&lt;/h2&gt;

&lt;p&gt;Add this functionality has been really easy since it is just and extension of the &lt;a href=&quot;https://marcalv.com/blog/001blogautomation&quot;&gt;blog automation script&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;An RSS feed is an XML file that contains different fields, in this case: the blog entry itself, title and date mainly. Just like I generate an HTML index with the markdown files, now I create an &lt;code&gt;.xml&lt;/code&gt; file containing all the previous information. When a new entry is created, the script regenerates the XML file that now will contain one new item. Your feed aggregator will detect it and notify you.&lt;/p&gt;

&lt;p&gt;This XML file can be found &lt;a href=&quot;https://marcalv.com/blog/rss.xml&quot;&gt;here&lt;/a&gt;. That link is also the url that you can add to your feed aggregator. If you want to take a look at the script that generates the feed and all the HTML files, it&amp;rsquo;s &lt;a href=&quot;https://github.com/marcalv/mywebpage/blob/master/blog/convert.sh&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
</item>
<item>
<title>Blog automation: write Markdown, get HTML</title>
<link>https://marcalv.com/blog/001blogautomation</link>
<guid>001blogautomation</guid>
<author>Marc Álvarez</author>
<pubDate>Mon, 13 Jul 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:Blog automation: write Markdown, get HTML_--&gt;


&lt;!--pubdate:2020/07/13_--&gt;


&lt;!--moddate:2020/07/13_--&gt;


&lt;!--icon:book_--&gt;


&lt;h2&gt;Writing in HTML isn&amp;rsquo;t that cool&lt;/h2&gt;

&lt;p&gt;I have written my whole web in HTML line by line, or in other words, I have not used any framework. Writing a blog in this language is not very convenient. That is why I have created a little &lt;a href=&quot;https://en.wikipedia.org/wiki/Bash_(Unix_shell&quot;&gt;bash&lt;/a&gt; script that converts Markdown files (one per blog entry) to HTML and automagically integrates them on the web.&lt;/p&gt;

&lt;p&gt;For those who don&amp;rsquo;t know what markdown is, it&amp;rsquo;s a language for writing documents with format (different level headers, bold, italic, tables, graphs&amp;hellip;) in a very simple way. Any simple plain text processor is enough to begin create a Markdown file.&lt;/p&gt;

&lt;h4&gt;Markdown demonstration&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Below&lt;/strong&gt; you can see how this paragraph is written in Markdown format. &lt;a href=&quot;https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet&quot;&gt;Here&lt;/a&gt; you have more information on what you can do with it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#### Markdown demonstration
**Below** you can see how this paragraph is written in Markdown format. [Here](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) you have more information on what you can do with it.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;How the automation works&lt;/h2&gt;

&lt;p&gt;The script must be executed every time an HTML template has been modified, or a new Markdown file (new entry) is created. Currently the script is placed at &lt;code&gt;blog/convert.sh&lt;/code&gt;, HTML templates in &lt;code&gt;blog/templates&lt;/code&gt; and &lt;code&gt;.md&lt;/code&gt; (Markdown) files in &lt;code&gt;blog/md&lt;/code&gt;. When the script is executed, the following files are generated:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;blog/index.html&lt;/code&gt;:  blog index page, containing a link to every entry.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blog/entry_id.html&lt;/code&gt;: entry page containing an HTML version of the file &lt;code&gt;blog/md/entry_id.html&lt;/code&gt;. This occurs for every &lt;code&gt;.md&lt;/code&gt; file inside &lt;code&gt;blog/md&lt;/code&gt; folder.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As you may have noticed, every blog entry has associated an icon that is shown at the index and in the entry itself. This information as well as date of publication and modification and title of the entry are declared at the beginning of the &lt;code&gt;.md&lt;/code&gt; file following this structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!--name:About this website--&amp;gt;
&amp;lt;!--pubdate:2020/07/09--&amp;gt;
&amp;lt;!--moddate:2020/07/10--&amp;gt;
&amp;lt;!--icon:web--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this functionality, I do not have to deal with HTML code at all in order to post a new entry. Everything is done in the &lt;code&gt;.md&lt;/code&gt; file.&lt;/p&gt;

&lt;h2&gt;Source code&lt;/h2&gt;

&lt;p&gt;Just like my whole website, you can find the source code of this &lt;a href=&quot;https://github.com/marcalv/mywebpage/blob/master/blog/convert.sh&quot;&gt;script&lt;/a&gt; and the folder containing all my &lt;a href=&quot;https://github.com/marcalv/mywebpage/tree/master/blog/md&quot;&gt;blog entries&lt;/a&gt; in &lt;code&gt;.md&lt;/code&gt; format in my  &lt;a href=&quot;Github%20repository&quot;&gt;Github repository&lt;/a&gt;.&lt;/p&gt;
</description>
</item>
<item>
<title>About this website</title>
<link>https://marcalv.com/blog/000thiswebsite</link>
<guid>000thiswebsite</guid>
<author>Marc Álvarez</author>
<pubDate>Thu, 09 Jul 2020 00:00:00 +0200</pubDate>
<source>https://marcalv.com/blog/rss.xml</source>
<description>
&lt;!--name:About this website_--&gt;


&lt;!--pubdate:2020/07/09_--&gt;


&lt;!--moddate:2020/07/10_--&gt;


&lt;!--icon:web_--&gt;


&lt;h2&gt;Where is marcalv.com?&lt;/h2&gt;

&lt;p&gt;When you enter the address marcalv.com you are connecting directly to my self-hosted home server: a simple &lt;a href=&quot;https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/&quot;&gt;Raspberry Pi 3 B+&lt;/a&gt;. All the files needed to make the website work are stored on it.&lt;/p&gt;

&lt;p&gt;The domain &lt;a href=&quot;https://marcalv.com&quot;&gt;marcalv.com&lt;/a&gt; is rented with &lt;a href=&quot;https://www.namecheap.com&quot;&gt;Namecheap&lt;/a&gt; for 8 euros per year. Besides, this service includes the redirection of the traffic to my home&amp;rsquo;s public IP (dynamic DNS).&lt;/p&gt;

&lt;h2&gt;How is it built?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/marcalv/mywebpage&quot;&gt;Here you have the repository with all the source code&lt;/a&gt;.It&amp;rsquo;s mostly HTML and CSS written line by line, and in some parts javascript (only if it&amp;rsquo;s strictly necessary). And if you know it, you may have noticed&amp;hellip; &lt;a href=&quot;https://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt; Icons are from &lt;a href=&quot;https://icons8.com/&quot;&gt;Icons8&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All files are served through &lt;a href=&quot;https://www.nginx.com/&quot;&gt;NGINX&lt;/a&gt;, which runs in a wonderful &lt;a href=&quot;https://github.com/linuxserver/docker-letsencrypt&quot;&gt;docker container&lt;/a&gt; that is used as a reverse proxy with other private access services that are also runinng on the Raspberry: (&lt;a href=&quot;https://nextcloud.com/&quot;&gt;Nextcloud&lt;/a&gt;, &lt;a href=&quot;https://pi-hole.net/&quot;&gt;Pi-hole&lt;/a&gt;, &lt;a href=&quot;https://freshrss.org/&quot;&gt;freshRSS&lt;/a&gt;, &lt;a href=&quot;https://github.com/linuxserver/docker-qbittorrent&quot;&gt;qBittorrent&lt;/a&gt;, &lt;a href=&quot;https://github.com/Jackett/Jackett&quot;&gt;Jackett&lt;/a&gt;&amp;hellip;).&lt;/p&gt;

&lt;h2&gt;Why?&lt;/h2&gt;

&lt;p&gt;Here below I try to justify the existence of this site:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Group together everything I do related to music and programming in general. Publish in my own website gives me total control and freedom over the content, aesthetics and behaviour.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a way to &lt;em&gt;force myself&lt;/em&gt; to document all the projects I develop, and more importantly, &lt;strong&gt;finish&lt;/strong&gt; them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Here you can find my contact details and other personal information easily: download the latest version of my CV or dial my phone number with a single click from the &lt;a href=&quot;/&quot;&gt;home page&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;This is my little personal place on the web, isn&amp;rsquo;t it that cool?&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Last but not least: because it&amp;rsquo;s fun, I learn a lot and I find it much more interesting than wasting my time on Instagram.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>
    </channel>
</rss>
